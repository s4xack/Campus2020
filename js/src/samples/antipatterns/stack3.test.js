import { assert } from "chai";
import Stack from '../../lib/stack.js'

describe("Stack3", () => {
    it("test", () => {
        const stack = new Stack();
        assert.isFalse(stack.any());
        stack.push(1);
        stack.pop();
        assert.isFalse(stack.any());

        stack.push(1);
        stack.push(2);
        stack.push(3);
        assert.equal(stack.count(), 3);

        stack.pop();
        stack.pop();
        stack.pop();
        assert.isFalse(stack.any());

        for (let i = 0; i < 1000; i++) {
            stack.push(i);
        }
        for (let i = 1000; i > 0; i--) {
            assert.equal(stack.pop(), i - 1);
        }
    });

    //#region Почему это плохо?

    /*
    ## Антипаттерн Freeride

    1. Непонятна область его ответственности. Складывается впечатление, что он тестирует все, однако он это делает плохо.
    Он дает ложное чувство, что все протестировано. Хотя, например, этот тест не проверяет много важных случаев.

    2. Таким тестам как-правило невозможно придумать внятное название.

    3. Если что-то упадет в середине теста, будет сложно разобраться что именно пошло не так и сложно отлаживать — нужно жонглировать точками останова.

    4. Такой тест не работает как документация. По этому сценарию непросто восстановить требования к тестируемому объекту.

    ## Мораль

    Каждый тест должен тестировать одно конкретное требование. Это требование должно отражаться в названии теста.
    Если вы не можете придумать название теста, у вас Loudmouth!
    */

    //#endregion
});